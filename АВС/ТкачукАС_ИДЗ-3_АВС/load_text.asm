# load_text.asm
.include "macrolib.asm"

.eqv TEXT_SIZE 512        			# Размер буфера для чтения
.eqv MAX_FILE_SIZE 10240			# Максимальный допустимый размер для чтения файла

.data
strbuf:	.space TEXT_SIZE			# Буфер для читаемого текста
.text

.globl load_text
load_text:
    # Открываем входной файл для чтения
    open READ_ONLY          # Вызов макроса open, a0 = дескриптор файла или -1
    li	s1, -1				# Загрузка -1 в s1 для проверки ошибок
    beq	a0, s1, error_name		# Если a0 == -1, перейти к обработке ошибки открытия файла
    mv  s0, a0       		# Сохранение дескриптора файла в s0

    # Выделение начального блока памяти для буфера в куче
    allocate TEXT_SIZE		# Вызов макроса allocate, результат в a0
    mv 	 s3, a0				# Сохранение адреса кучи в s3 (начало буфера)
    mv 	 s5, a0				# Сохранение изменяемого адреса буфера в s5
    li	 s4, TEXT_SIZE		# Сохранение константы размера буфера в s4
    mv	 s6, zero			# Инициализация общего количества прочитанных байт в s6

read_loop:
    # Чтение информации из открытого файла
    read s0, strbuf, TEXT_SIZE	# Вызов макроса read, результат в a0 (количество прочитанных байт или -1)
    beq	a0, s1, error_read		# Если a0 == -1, перейти к обработке ошибки чтения
    mv  s2, a0       		# Сохранение количества прочитанных байт в s2
    add s6, s6, s2			# Увеличение общего количества прочитанных байт на s2

    # Копирование данных из strbuf в выделенный буфер s3
    # Используем регистры t0 - источник, t1 - назначение, t2 - количество байт
    la t0, strbuf       	# Адрес начала strbuf
    mv t1, s5           	# Текущий адрес в выделенном буфере
    mv t2, s2           	# Количество байт для копирования

copy_loop:
    beq t2, zero, copy_done   # Если все байты скопированы, выйти из цикла
    lb  t3, 0(t0)             # Загрузка байта из strbuf
    sb  t3, 0(t1)             # Сохранение байта в выделенный буфер
    addi t0, t0, 1            # Увеличение адреса источника
    addi t1, t1, 1            # Увеличение адреса назначения
    addi t2, t2, -1           # Уменьшение счётчика байт
    j    copy_loop            # Переход к следующей итерации

copy_done:
    mv  s5, t1                # Обновление текущего адреса в выделенном буфере
    # Если количество прочитанных байт меньше размера буфера, завершить чтение
    bne	s2, s4, end_loop
    
     # Если общее количество прочитанных байт равно 10KB (10240), завершить чтение
    li  t0, MAX_FILE_SIZE     # Загружаем 10KB в t0
    beq s6, t0, end_loop      # Если s6 == 10240, перейти к завершению
    
    # Иначе, выделить дополнительную память и продолжить чтение
    allocate TEXT_SIZE			# Вызов макроса allocate для расширения буфера
    beq a0, s1, error_alloc      	# Проверка на ошибку выделения памяти
    mv  s5, a0                	# Установка нового текущего адреса в s5
    j    read_loop            	# Повторить цикл чтения

error_alloc:
    # Обработка ошибки выделения памяти
    li a0, -1                  # a0 = -1
    li a1, 0                   # a1 = 0
    ret                        # Возврат из подпрограммы

end_loop:
    # Закрытие файла
    close s0				# Вызов макроса close для закрытия файла
    # Установка нуля в конце прочитанной строки
    sb	 zero, 0(s5)		# Запись нулевого байта в конец текста

    # Установка возвращаемых значений
    mv a0, s3            	# a0 = адрес буфера
    mv a1, s6            	# a1 = всего прочитанных байт
    ret                   	# Возврат из подпрограммы

error_name:
    # Возврат -1 и 0 при ошибке открытия файла
    li a0, -1              	# a0 = -1
    li a1, 0               	# a1 = 0
    ret                    	# Возврат из подпрограммы

error_read:
    # Возврат -1 и 0 при ошибке чтения файла
    li a0, -1              	# a0 = -1
    li a1, 0               	# a1 = 0
    ret                    	# Возврат из подпрограммы
